"use strict";(self.webpackChunkwebsite=self.webpackChunkwebsite||[]).push([[31600],{83499:(e,n,t)=>{t.r(n),t.d(n,{assets:()=>s,contentTitle:()=>r,default:()=>m,frontMatter:()=>o,metadata:()=>l,toc:()=>p});var i=t(87462),a=(t(67294),t(3905));const o={sidebar_position:3},r="Authorization",l={unversionedId:"docs/authorization",id:"docs/authorization",title:"Authorization",description:"GraphGlue only provides Authorization features. Authentication must be implemented by the user, for example using OpenID Connect",source:"@site/docs/docs/authorization.mdx",sourceDirName:"docs",slug:"/docs/authorization",permalink:"/graph-glue/docs/authorization",draft:!1,tags:[],version:"current",sidebarPosition:3,frontMatter:{sidebar_position:3},sidebar:"docSidebar",previous:{title:"Modeling",permalink:"/graph-glue/docs/modeling"},next:{title:"Connections",permalink:"/graph-glue/docs/connections"}},s={},p=[{value:"Declaration",id:"declaration",level:2},{value:"Overview",id:"overview",level:3},{value:"Rule",id:"rule",level:3},{value:"Inheritance",id:"inheritance",level:3},{value:"Checking",id:"checking",level:2},{value:"Permission",id:"permission",level:3},{value:"GraphQL",id:"graphql",level:3},{value:"Manually",id:"manually",level:3}],d={toc:p};function m(e){let{components:n,...t}=e;return(0,a.kt)("wrapper",(0,i.Z)({},d,t,{components:n,mdxType:"MDXLayout"}),(0,a.kt)("h1",{id:"authorization"},"Authorization"),(0,a.kt)("admonition",{type:"caution"},(0,a.kt)("p",{parentName:"admonition"},"GraphGlue only provides Authorization features. Authentication must be implemented by the user, for example using OpenID Connect")),(0,a.kt)("h2",{id:"declaration"},"Declaration"),(0,a.kt)("p",null,"To declare Permissions, GraphGlue uses a declarative approach, meaning authorizations are declared using the ",(0,a.kt)("inlineCode",{parentName:"p"},"@Authorization")," annotation on ",(0,a.kt)("inlineCode",{parentName:"p"},"Node")," subtypes.\nCurrently, only node-level permissions are supported, while field-level permissions are not.\nHowever, if you need field-level permissions, ",(0,a.kt)("a",{parentName:"p",href:"#manually"},"checking manually")," is possible."),(0,a.kt)("h3",{id:"overview"},"Overview"),(0,a.kt)("p",null,"Declaraing a permission looks like this:"),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-kotlin"},'@DomainNode\n@Authorization(\n    name = "READ",\n    allow = [Rule("leafAllowedBean")],\n    allowFromRelated = ["tree"],\n    disallow = [Rule("leafDisallowedBean")]\n)\nclass Leaf : Node() {\n    @NodeRelationship("LEAF", Direction.OUTGOING)\n    @delegate:Transient\n    val tree by NodeProperty<Tree>()\n}\n')),(0,a.kt)("p",null,"The ",(0,a.kt)("inlineCode",{parentName:"p"},"name")," is used to identify the permission to check, it is later referenced in ",(0,a.kt)("a",{parentName:"p",href:"#checking"},"Checking"),"."),(0,a.kt)("p",null,"The checking algorithm works in two steps:"),(0,a.kt)("ol",null,(0,a.kt)("li",{parentName:"ol"},(0,a.kt)("p",{parentName:"li"},"Check if access is allowed. Access is allowed if any ",(0,a.kt)("inlineCode",{parentName:"p"},"Rule")," in ",(0,a.kt)("inlineCode",{parentName:"p"},"allow")," evaluates to ",(0,a.kt)("inlineCode",{parentName:"p"},"true"),", OR if the permission with ",(0,a.kt)("inlineCode",{parentName:"p"},"name")," is granted to any node referenced in ",(0,a.kt)("inlineCode",{parentName:"p"},"allowFromRelated"),", or if ",(0,a.kt)("inlineCode",{parentName:"p"},"allowAll")," is ",(0,a.kt)("inlineCode",{parentName:"p"},"true"),".\nIf neither of these conditions is fulfilled, the permission is NOT granted.\nEspecially, if ",(0,a.kt)("inlineCode",{parentName:"p"},"allow")," and ",(0,a.kt)("inlineCode",{parentName:"p"},"allowFromRelated")," are both empty, allow is not granted."),(0,a.kt)("admonition",{parentName:"li",type:"caution"},(0,a.kt)("p",{parentName:"admonition"}," If any ",(0,a.kt)("inlineCode",{parentName:"p"},"NodeSetProperty")," is referenced in ",(0,a.kt)("inlineCode",{parentName:"p"},"allowFromRelated"),", allow is granted if the permission is granted to ANY of the related nodes."))),(0,a.kt)("li",{parentName:"ol"},(0,a.kt)("p",{parentName:"li"},"Check if access is disallowed. Access is granted if an only if NO ",(0,a.kt)("inlineCode",{parentName:"p"},"Rule")," in ",(0,a.kt)("inlineCode",{parentName:"p"},"disallow")," evaluates to ",(0,a.kt)("inlineCode",{parentName:"p"},"true"),"."))),(0,a.kt)("p",null,"In this example, allow is granted if the ",(0,a.kt)("inlineCode",{parentName:"p"},'"leftAllowedBean"')," Rule evaluate to ",(0,a.kt)("inlineCode",{parentName:"p"},"true"),", OR if ",(0,a.kt)("inlineCode",{parentName:"p"},'"READ"')," is granted to ",(0,a.kt)("inlineCode",{parentName:"p"},"tree"),".\nThen, the permission is granted if also ",(0,a.kt)("inlineCode",{parentName:"p"},'"leafDisallowedBean"')," evaluates to ",(0,a.kt)("inlineCode",{parentName:"p"},"false")),(0,a.kt)("h3",{id:"rule"},"Rule"),(0,a.kt)("p",null,"A ",(0,a.kt)("inlineCode",{parentName:"p"},"Rule")," consists of two parts: a ",(0,a.kt)("inlineCode",{parentName:"p"},"String")," that references a Spring bean of type ",(0,a.kt)("inlineCode",{parentName:"p"},"AllowRuleGenerator"),"/",(0,a.kt)("inlineCode",{parentName:"p"},"DisllowRuleGenerator"),", and a list of Strings used as configuration parameters."),(0,a.kt)("p",null,"Example:"),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-kotlin"},'@Bean("startsWithRule")\nfun startsWithRuleGenerator(): DisallowRuleGenerator {\n    return DisallowRuleGenerator { node, rule, permission ->\n        val requiredPrefix = (permission.context as MyAuthorizationContext).prefix\n        node.property(rule.options[0]).startsWith(Cypher.anonParameter(requiredPrefix))\n    }\n}\n')),(0,a.kt)("p",null,"This rule checks if a String property on ",(0,a.kt)("inlineCode",{parentName:"p"},"node")," with a name provided as first configuration parameter has NOT a prefix provided in the permission to check.\nIt can be used like this:"),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-kotlin"},'@DomainNode\n@Authorization("READ", disallow = [Rule("startsWithRule", "name")])\nclass NamedNode(val name: String) : Node()\n')),(0,a.kt)("p",null,(0,a.kt)("inlineCode",{parentName:"p"},"AllowRuleGenerator")," works the same, with the difference that is is provided a ",(0,a.kt)("inlineCode",{parentName:"p"},"RelationshipPattern")," it can extend and must return.\nThis can be used to improve the performance of the check, as without the possibility to continue the pattern, a worse performing existential subquery would be necessary."),(0,a.kt)("p",null,"Note that the ",(0,a.kt)("inlineCode",{parentName:"p"},"AllowRuleGenerator"),"/",(0,a.kt)("inlineCode",{parentName:"p"},"DisllowRuleGenerator")," generates a ",(0,a.kt)("a",{parentName:"p",href:"https://neo4j-contrib.github.io/cypher-dsl/current/"},"CypherDSL")," ",(0,a.kt)("inlineCode",{parentName:"p"},"Conditon"),", which allows checking complex conditions directly in the database."),(0,a.kt)("admonition",{type:"caution"},(0,a.kt)("p",{parentName:"admonition"},"Disallow rules affect all nodes in the ",(0,a.kt)("inlineCode",{parentName:"p"},"RelationshipPattern")," generated by the allow rule.")),(0,a.kt)("h3",{id:"inheritance"},"Inheritance"),(0,a.kt)("p",null,"The algorithm first searches for all ",(0,a.kt)("inlineCode",{parentName:"p"},"@Authorization")," annotations with the specified ",(0,a.kt)("inlineCode",{parentName:"p"},"name"),".\nThis includes annotations from superclasses.\nIt is even possible to use multiple ",(0,a.kt)("inlineCode",{parentName:"p"},"@Authorization")," annotations with the same ",(0,a.kt)("inlineCode",{parentName:"p"},"name")," on the same class, although this is not recommended."),(0,a.kt)("h2",{id:"checking"},"Checking"),(0,a.kt)("h3",{id:"permission"},"Permission"),(0,a.kt)("p",null,"Generally, it is checked if a ",(0,a.kt)("inlineCode",{parentName:"p"},"Permission")," is granted to a ",(0,a.kt)("inlineCode",{parentName:"p"},"Node")),(0,a.kt)("p",null,"A ",(0,a.kt)("inlineCode",{parentName:"p"},"Permission")," consists of two parts"),(0,a.kt)("ul",null,(0,a.kt)("li",{parentName:"ul"},"The name of the permission to be checked"),(0,a.kt)("li",{parentName:"ul"},"A ",(0,a.kt)("inlineCode",{parentName:"li"},"AuthorizationContext")," instance. It is intended implement this interface in order to provide custom values to ",(0,a.kt)("inlineCode",{parentName:"li"},"AuthorizationRuleGenerator")," instances, e.g. the id of the authenticated user, or a role String.")),(0,a.kt)("h3",{id:"graphql"},"GraphQL"),(0,a.kt)("p",null,"To automatically check permissions, provide a ",(0,a.kt)("inlineCode",{parentName:"p"},"Permission")," to the ",(0,a.kt)("a",{parentName:"p",href:"https://opensource.expediagroup.com/graphql-kotlin/docs/server/spring-server/spring-graphql-context"},"GraphQL Context Map")," under the key ",(0,a.kt)("inlineCode",{parentName:"p"},"Permission::class"),"."),(0,a.kt)("p",null,"Permissions are checked at"),(0,a.kt)("ul",null,(0,a.kt)("li",{parentName:"ul"},"the ",(0,a.kt)("inlineCode",{parentName:"li"},"node")," query"),(0,a.kt)("li",{parentName:"ul"},"queries generated using the ",(0,a.kt)("inlineCode",{parentName:"li"},"name")," parameter of the ",(0,a.kt)("inlineCode",{parentName:"li"},"@DomainNode")," annotation"),(0,a.kt)("li",{parentName:"ul"},(0,a.kt)("a",{parentName:"li",href:"./modeling#graphglue-relationships"},"GraphGlue relationship properties"))),(0,a.kt)("admonition",{type:"warning"},(0,a.kt)("p",{parentName:"admonition"},"Any other properties returning ",(0,a.kt)("inlineCode",{parentName:"p"},"Node")," types are NOT automatically checked!\nThis is due to checking is only done directly in the database.\nThis is espacially the case when returning nodes from functions which use the lazy-loading functionality of GraphGlue relationships, or when returning nodes in mutations."),(0,a.kt)("p",{parentName:"admonition"},"Consider the following example with the ",(0,a.kt)("inlineCode",{parentName:"p"},"Leaf")," class from ",(0,a.kt)("a",{parentName:"p",href:"#overview"},"above")),(0,a.kt)("pre",{parentName:"admonition"},(0,a.kt)("code",{parentName:"pre",className:"language-kotlin"},"data class CreateLeafOutput(val leaf: Leaf)\n")),(0,a.kt)("p",{parentName:"admonition"},"When returing this, ",(0,a.kt)("inlineCode",{parentName:"p"},"leaf")," is NOT checked, however, note that the permission is checked for GraphGlue relationships on ",(0,a.kt)("inlineCode",{parentName:"p"},"leaf"),", in this example the ",(0,a.kt)("inlineCode",{parentName:"p"},"tree")," property.")),(0,a.kt)("admonition",{type:"info"},(0,a.kt)("p",{parentName:"admonition"},"Permissions are only checked if necessary.\nConsidering the ",(0,a.kt)("a",{parentName:"p",href:"#overview"},"above"),", if ",(0,a.kt)("inlineCode",{parentName:"p"},"leafs")," is accessed on ",(0,a.kt)("inlineCode",{parentName:"p"},"Tree"),", allow is not checked as ",(0,a.kt)("inlineCode",{parentName:"p"},"Leaf")," allows from related ",(0,a.kt)("inlineCode",{parentName:"p"},"tree"),".")),(0,a.kt)("h3",{id:"manually"},"Manually"),(0,a.kt)("p",null,"Permissions can be manually checked by injecting a ",(0,a.kt)("inlineCode",{parentName:"p"},"AuthorizationChecker")," bean.\nIt provides a ",(0,a.kt)("inlineCode",{parentName:"p"},"hasAuthorization")," function, which takes a ",(0,a.kt)("inlineCode",{parentName:"p"},"Node")," and a ",(0,a.kt)("inlineCode",{parentName:"p"},"Permission")," as input, and returns whether the permission is granted on the node."),(0,a.kt)("p",null,"While it is up to the user to provide the required ",(0,a.kt)("inlineCode",{parentName:"p"},"Permission"),", the recommended way is to put it into the GraphQL Context Map as described in ",(0,a.kt)("a",{parentName:"p",href:"#graphql"},"GraphQL"),", and then obtain it using an ",(0,a.kt)("a",{parentName:"p",href:"https://opensource.expediagroup.com/graphql-kotlin/docs/schema-generator/execution/data-fetching-environment/"},"injected DataFetchingEnvironment"),".",(0,a.kt)("br",{parentName:"p"}),"\n","Example:"),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-kotlin"},'@Component\nclass LeafMutations: Mutation {\n    fun createLeaf(input: CreateLeafInput, dfe: DataFetchingEnvironment): CreateLeafOutput {\n        val readPermission = dfe.requiredPermission // gives access to the permission under the key Permission::class\n        val myPermission = Permission("WRITE", dfe.authorizationContext) // AuthorizationContext from the Permission\n        // ...\n    }\n}\n')),(0,a.kt)("admonition",{type:"tip"},(0,a.kt)("p",{parentName:"admonition"},"If automatic permission checking in GraphQL is not wanted, it is also possible to only provide the ",(0,a.kt)("inlineCode",{parentName:"p"},"AuthorizationContext")," under the key ",(0,a.kt)("inlineCode",{parentName:"p"},"AuthorizationContext::class")," to the GraphQL Context Map")))}m.isMDXComponent=!0}}]);