"use strict";(self.webpackChunkwebsite=self.webpackChunkwebsite||[]).push([[19218],{3697:(e,t,n)=>{n.r(t),n.d(t,{assets:()=>p,contentTitle:()=>r,default:()=>h,frontMatter:()=>o,metadata:()=>l,toc:()=>s});var i=n(87462),a=(n(67294),n(3905));const o={sidebar_position:2},r="Modeling",l={unversionedId:"docs/modeling",id:"docs/modeling",title:"Modeling",description:"As this library is based on GraphQL Kotlin and Spring Data Neo4j, the modeling is mostly a merge of their approaches.",source:"@site/docs/docs/modeling.mdx",sourceDirName:"docs",slug:"/docs/modeling",permalink:"/graph-glue/docs/modeling",draft:!1,tags:[],version:"current",sidebarPosition:2,frontMatter:{sidebar_position:2},sidebar:"docSidebar",previous:{title:"Getting started",permalink:"/graph-glue/"},next:{title:"Authorization",permalink:"/graph-glue/docs/authorization"}},p={},s=[{value:"Overview",id:"overview",level:2},{value:"Class Definition",id:"class-definition",level:2},{value:"Properties",id:"properties",level:2},{value:"Functions",id:"functions",level:2},{value:"Relationships",id:"relationships",level:2},{value:"GraphGlue relationships",id:"graphglue-relationships",level:3},{value:"Spring Data Neo4j relationships",id:"spring-data-neo4j-relationships",level:3},{value:"Comparison",id:"comparison",level:3},{value:"Inheritance",id:"inheritance",level:2},{value:"Ordering &amp; Filtering",id:"ordering--filtering",level:2},{value:"Ordering",id:"ordering",level:3},{value:"Filtering",id:"filtering",level:3},{value:"Filters for properties",id:"filters-for-properties",level:4},{value:"Additional filters",id:"additional-filters",level:4},{value:"Node filter generators",id:"node-filter-generators",level:4}],d={toc:s};function h(e){let{components:t,...n}=e;return(0,a.kt)("wrapper",(0,i.Z)({},d,n,{components:t,mdxType:"MDXLayout"}),(0,a.kt)("h1",{id:"modeling"},"Modeling"),(0,a.kt)("admonition",{type:"info"},(0,a.kt)("p",{parentName:"admonition"},"As this library is based on GraphQL Kotlin and Spring Data Neo4j, the modeling is mostly a merge of their approaches.\nAlmost all of their features still work when using this library. For more information on their features, please have a look at\n",(0,a.kt)("a",{parentName:"p",href:"https://opensource.expediagroup.com/graphql-kotlin/docs/schema-generator/schema-generator-getting-started"},"GraphQL Kotlin")," and\n",(0,a.kt)("a",{parentName:"p",href:"https://docs.spring.io/spring-data/neo4j/docs/current/reference/html/#mapping"},"Spring Data Neo4j"))),(0,a.kt)("h2",{id:"overview"},"Overview"),(0,a.kt)("p",null,"Consider the following example of a ",(0,a.kt)("inlineCode",{parentName:"p"},"Node"),":"),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-kotlin"},'@DomainNode("trees")                                // (1)\n@Authorization("READ")                              // (2)\nclass Tree(\n    @OrderProperty @FilterProperty val age: Int,    // (3)\n    internal val name: String                       // (4)\n) : Node() {                                        // (5)\n    \n    @NodeRelationship("ROOT", Direction.OUTGOING)   // (6)\n    @delegate:Transient\n    val root by NodeProperty<Root>()\n    \n    @NodeRelationship("LEAF", Direction.OUTGOING)   // (7)\n    @delegate:Transient\n    val leafs by NodeSetProperty<Leaf>()\n    \n    fun ageInDays() = age * 365                     // (8)\n}\n')),(0,a.kt)("ol",null,(0,a.kt)("li",{parentName:"ol"},"Necessary annotation for all ",(0,a.kt)("inlineCode",{parentName:"li"},"Node")," classes. If the ",(0,a.kt)("inlineCode",{parentName:"li"},"name")," parameter is provided, a connection-like query with the name ",(0,a.kt)("inlineCode",{parentName:"li"},"name")," is exposed."),(0,a.kt)("li",{parentName:"ol"},"Specifies the ",(0,a.kt)("inlineCode",{parentName:"li"},"READ")," permission for this Node, for more info, see ",(0,a.kt)("a",{parentName:"li",href:"./authorization"},"Authorization")),(0,a.kt)("li",{parentName:"ol"},"Property which is exposed in the GraaphQL schema. As it is annotated with both ",(0,a.kt)("inlineCode",{parentName:"li"},"@OrderProperty")," and ",(0,a.kt)("inlineCode",{parentName:"li"},"@FilterProperty"),", connections of type ",(0,a.kt)("inlineCode",{parentName:"li"},"Tree")," can both be filtered and ordered by this property."),(0,a.kt)("li",{parentName:"ol"},"Internal property NOT exposed in the GraphQL schema."),(0,a.kt)("li",{parentName:"ol"},"Each class needs to extend ",(0,a.kt)("inlineCode",{parentName:"li"},"Node")," in order to use any GraphGlue specific features."),(0,a.kt)("li",{parentName:"ol"},"An outgoing relation of type ",(0,a.kt)("inlineCode",{parentName:"li"},"Root"),"."),(0,a.kt)("li",{parentName:"ol"},"An outgoing relation of type ",(0,a.kt)("inlineCode",{parentName:"li"},"Set<Leaf>"),". In the GraphQL schema, it is exposed as ",(0,a.kt)("inlineCode",{parentName:"li"},"LeafConnection")),(0,a.kt)("li",{parentName:"ol"},"Function exposed as field in the GraphQL schema.")),(0,a.kt)("h2",{id:"class-definition"},"Class Definition"),(0,a.kt)("p",null,"Each node class both has to be annotated with ",(0,a.kt)("inlineCode",{parentName:"p"},"@DomainNode")," and extend ",(0,a.kt)("inlineCode",{parentName:"p"},"io.github.graphglue.model.Node"),".\nIf any of those conditions is missing, GraphGlue-specific features might not work."),(0,a.kt)("admonition",{type:"tip"},(0,a.kt)("p",{parentName:"admonition"},"This does not mean that you never should use classes which fullfill neither of those criteries.\nFor example, a non-node class can be used as type for properties with a struct-like type: it is still persisted in the database as node, however, in the GraphQL schema, it does not implement ",(0,a.kt)("inlineCode",{parentName:"p"},"Node"),", meaning it is not possible to retrieve it via the ",(0,a.kt)("inlineCode",{parentName:"p"},"node")," query.")),(0,a.kt)("p",null,"The Node class also defines an id. In Kotlin, it is possible to access the id using the ",(0,a.kt)("inlineCode",{parentName:"p"},"rawId")," String property.\nIt is not possible to manually assign an id, as a id is automatically generated when the node is first saved.\nHowever, the generation can be customized by providing a bean with the name ",(0,a.kt)("inlineCode",{parentName:"p"},"io.github.graphglue.model.NODE_ID_GENERATOR_BEAN")," and the type ",(0,a.kt)("inlineCode",{parentName:"p"},"IdGenerator<String>"),".\nBy default, a random UUID is generated. "),(0,a.kt)("h2",{id:"properties"},"Properties"),(0,a.kt)("p",null,"Properties are both used to expose fields in the GraphQL schema, and save properties on the node in the database.\nBy default, both Spring Data Neo4j and GraphQL Kotlin use the name of the property as name, however, the name in the GraphQL schema can be changed by annotating it with ",(0,a.kt)("inlineCode",{parentName:"p"},'@GraphQLName("name")'),", the name of the property in the database can be changed by annotating it with ",(0,a.kt)("inlineCode",{parentName:"p"},'@Property("name")'),"."),(0,a.kt)("admonition",{type:"caution"},(0,a.kt)("p",{parentName:"admonition"},"Spring Data Neo4j and GraphQL Kotlin use different visibilities.\nWhile property backed by a field (this includes delegated properties) is saved in the database. GraphQL Kotlin only exposes ",(0,a.kt)("inlineCode",{parentName:"p"},"public")," properties not annotated with ",(0,a.kt)("inlineCode",{parentName:"p"},"@GraphQLIgnore"),".")),(0,a.kt)("admonition",{type:"tip"},(0,a.kt)("p",{parentName:"admonition"},"GraphGlue automatically adds all injected ",(0,a.kt)("inlineCode",{parentName:"p"},"GraphQLType"),"s to the generated schema.\nThis allows for injecting custom scalars, and then using the name in ",(0,a.kt)("inlineCode",{parentName:"p"},"@GraphQLType")," annotations.")),(0,a.kt)("p",null,"The used type must both be supported by GraphQL Kotlin and Spring Data Neo4j, however, both libaries provide extension mechanisms which allow you to support additional types."),(0,a.kt)("h2",{id:"functions"},"Functions"),(0,a.kt)("p",null,"Like properties, functions can be used to expose field in the GraphQL schema."),(0,a.kt)("h2",{id:"relationships"},"Relationships"),(0,a.kt)("h3",{id:"graphglue-relationships"},"GraphGlue relationships"),(0,a.kt)("p",null,"Declaration of one-sides of relationships"),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-kotlin"},"@NodeRelationship(label, direction)\n@delegate:Transient\nval propertyName by NodeProperty<NodeType>()\n")),(0,a.kt)("p",null,"Declaration of many-sides of relationships"),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-kotlin"},"@NodeRelationship(label, direction)\n@delegate:Transient\nval propertyName by NodeSetProperty<NodeType>()\n")),(0,a.kt)("p",null,"where ",(0,a.kt)("inlineCode",{parentName:"p"},"label")," is a ",(0,a.kt)("inlineCode",{parentName:"p"},"String"),", and direction is either ",(0,a.kt)("inlineCode",{parentName:"p"},"Direction.INCOMING")," or ",(0,a.kt)("inlineCode",{parentName:"p"},"Direction.OUTGOING"),"."),(0,a.kt)("admonition",{type:"caution"},(0,a.kt)("p",{parentName:"admonition"},"Make sure to use ",(0,a.kt)("inlineCode",{parentName:"p"},"org.springframework.data.annotation.Transient"),".\nKotlin ",(0,a.kt)("inlineCode",{parentName:"p"},"Transient")," does not work and will result in strange errors, as Spring Data Neo4j tries to persist the backing field of the delegated property.")),(0,a.kt)("admonition",{type:"caution"},(0,a.kt)("p",{parentName:"admonition"},"To actually get the content of a property, you have to use the call operator on the property (e.g. ",(0,a.kt)("inlineCode",{parentName:"p"},"node.manyProperty().add(addedNode)"),").\nThis is necessary, as lazy loading is done asynchronous, and properties cannot be marked currently with ",(0,a.kt)("inlineCode",{parentName:"p"},"suspend"),".\nTherefore, on invoking, the property is - if necessary - loaded from the database.")),(0,a.kt)("p",null,"On save, all relationships are saved. Save cascades down added entities, but removed ones.\nExample: If the one side has initially the value ",(0,a.kt)("inlineCode",{parentName:"p"},"node1"),", which then is replaced with ",(0,a.kt)("inlineCode",{parentName:"p"},"node2"),", when saving, ",(0,a.kt)("inlineCode",{parentName:"p"},"node2"),' is saved (as it was "added"), while ',(0,a.kt)("inlineCode",{parentName:"p"},"node1")," is not."),(0,a.kt)("h3",{id:"spring-data-neo4j-relationships"},"Spring Data Neo4j relationships"),(0,a.kt)("p",null,"Declaration of one-sides of relationships"),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-kotlin"},"@Relationship(label, direction)\nval propertyName: NodeType\n")),(0,a.kt)("p",null,"Declaration of many-sides of relationships"),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-kotlin"},"@Relationship(label, direction)\nval propertyName: List<NodeType>\n")),(0,a.kt)("p",null,"For more information, see ",(0,a.kt)("a",{parentName:"p",href:"https://docs.spring.io/spring-data/neo4j/docs/current/reference/html/#mapping.annotations.relationship"},"Connecting nodes: @Relationship")),(0,a.kt)("h3",{id:"comparison"},"Comparison"),(0,a.kt)("table",null,(0,a.kt)("thead",null,(0,a.kt)("tr",null,(0,a.kt)("th",null),(0,a.kt)("th",null,"GraphGlue"),(0,a.kt)("th",null,"Spring Data Neo4j "))),(0,a.kt)("tbody",null,(0,a.kt)("tr",null,(0,a.kt)("th",null,"GraphQL representation"),(0,a.kt)("th",null,"One sides are represented by their appropriate type. Many sides are represented by connection types, supporting pagination, filtering and ordering"),(0,a.kt)("th",null,"One sides are represented by their appropriate type. Many sides are represented as GraphQL list, without pagination, filtering or ordering support")),(0,a.kt)("tr",null,(0,a.kt)("th",null,"Lazy loading"),(0,a.kt)("th",null,"Only lazy loading is supported. Relations are automatically loaded when accessed. Note: when fetching data for GraphQL, the whole subtree is loaded at once using one Cypher query, preventing the n+1 problem. Lazy loading is done asynchronous."),(0,a.kt)("th",null,"No lazy loading is supported, all relationships are eagerly loaded, which can result in large subgraphs being loaded. To prevent this, you may use",(0,a.kt)("a",{href:"https://docs.spring.io/spring-data/neo4j/docs/current/reference/html/#projections",rel:"noopener noreferer"},"Projections"))),(0,a.kt)("tr",null,(0,a.kt)("th",null,"Matching of opposite sides"),(0,a.kt)("th",{colSpan:"2"},"Opposite sides are matched if the `label` is the same, but the `direction` the opposite.")))),(0,a.kt)("h2",{id:"inheritance"},"Inheritance"),(0,a.kt)("p",null,"Currently, only inheriting from abstract classes is supported.\nSpecifically, inheriting from ",(0,a.kt)("inlineCode",{parentName:"p"},"open"),", non-",(0,a.kt)("inlineCode",{parentName:"p"},"abstract")," classes is only supported if it is marked with ",(0,a.kt)("inlineCode",{parentName:"p"},"@GraphQLIgnore"),".\nInheriting from interfaces is possible, however non of the GraphGlue annotations (",(0,a.kt)("inlineCode",{parentName:"p"},"@DomainNode"),", ",(0,a.kt)("inlineCode",{parentName:"p"},"@Authorization"),", ",(0,a.kt)("inlineCode",{parentName:"p"},"@AdditionalFilter"),") is supported there, however, it can e.g. be used to share common ",(0,a.kt)("inlineCode",{parentName:"p"},"@GraphQLDescriptions"),"."),(0,a.kt)("admonition",{type:"note"},(0,a.kt)("p",{parentName:"admonition"},"The ",(0,a.kt)("inlineCode",{parentName:"p"},"@DomainNode")," annotation is not inherited and has to be present on all node types.")),(0,a.kt)("h2",{id:"ordering--filtering"},"Ordering & Filtering"),(0,a.kt)("admonition",{type:"info"},(0,a.kt)("p",{parentName:"admonition"},"For more information on how to use ordering and filtering in GraphQL, see ",(0,a.kt)("a",{parentName:"p",href:"./connections"},"Connections"))),(0,a.kt)("h3",{id:"ordering"},"Ordering"),(0,a.kt)("p",null,"All nodes can be ordered by id.\nAdditionally, nodes of a specific type can also be ordered by all properties annotated with ",(0,a.kt)("inlineCode",{parentName:"p"},"@OrderProperty"),". As those might not be unique, the ",(0,a.kt)("inlineCode",{parentName:"p"},"id")," is used to create a strict total order.\nBy default, all data types which are ",(0,a.kt)("a",{parentName:"p",href:"https://neo4j.com/docs/cypher-manual/current/syntax/operators/#cypher-ordering"},"comparable in Cypher")," are supported."),(0,a.kt)("h3",{id:"filtering"},"Filtering"),(0,a.kt)("p",null,"Filters are generated for specific node types.\nThese filters are generated by concatenating property-based filter fields and additional filter fields.\nThen, for each type, a meta filter is created, which allows joining filters by and, or and not:"),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-graphql"},"input TypeNodeFilterInput {\n    # filter fields\n}\n\ninput TypeFilterInput {\n    and: [TypeFilterInput!]\n    or: [TypeFilterInput!]\n    not: TypeFilterInput\n    node: TypeNodeFilterInput\n}\n")),(0,a.kt)("p",null,"Exactly one of the specified fields has to be provided."),(0,a.kt)("h4",{id:"filters-for-properties"},"Filters for properties"),(0,a.kt)("p",null,"Properties can be annotated with ",(0,a.kt)("inlineCode",{parentName:"p"},"@FilterProperty")," to allow filtering by a specific property. By default, this is supported for properties with the following types:"),(0,a.kt)("ul",null,(0,a.kt)("li",{parentName:"ul"},(0,a.kt)("inlineCode",{parentName:"li"},"String")),(0,a.kt)("li",{parentName:"ul"},(0,a.kt)("inlineCode",{parentName:"li"},"Int")),(0,a.kt)("li",{parentName:"ul"},(0,a.kt)("inlineCode",{parentName:"li"},"Double")," (Float in GraphQL)"),(0,a.kt)("li",{parentName:"ul"},(0,a.kt)("inlineCode",{parentName:"li"},"Boolean")),(0,a.kt)("li",{parentName:"ul"},(0,a.kt)("inlineCode",{parentName:"li"},"ID")),(0,a.kt)("li",{parentName:"ul"},(0,a.kt)("inlineCode",{parentName:"li"},"by NodeProperty<*>")),(0,a.kt)("li",{parentName:"ul"},(0,a.kt)("inlineCode",{parentName:"li"},"by NodeSetProperty<*>"))),(0,a.kt)("p",null,"Input fields of filters are always optional. All the present fields are then joined by ",(0,a.kt)("inlineCode",{parentName:"p"},"&&"),".",(0,a.kt)("br",{parentName:"p"}),"\n","The input fields of the filter depends on the type: For ",(0,a.kt)("inlineCode",{parentName:"p"},"Boolean")," and ",(0,a.kt)("inlineCode",{parentName:"p"},"ID"),", only ",(0,a.kt)("inlineCode",{parentName:"p"},"eq")," and ",(0,a.kt)("inlineCode",{parentName:"p"},"in")," are available.\nFor all comparable types (",(0,a.kt)("inlineCode",{parentName:"p"},"Int"),", ",(0,a.kt)("inlineCode",{parentName:"p"},"Double")," and ",(0,a.kt)("inlineCode",{parentName:"p"},"String"),"), ",(0,a.kt)("inlineCode",{parentName:"p"},"lt"),", ",(0,a.kt)("inlineCode",{parentName:"p"},"lte"),", ",(0,a.kt)("inlineCode",{parentName:"p"},"gt")," and ",(0,a.kt)("inlineCode",{parentName:"p"},"gte")," are additionally available.\nFinally, for ",(0,a.kt)("inlineCode",{parentName:"p"},"String"),", ",(0,a.kt)("inlineCode",{parentName:"p"},"startsWith"),", ",(0,a.kt)("inlineCode",{parentName:"p"},"endsWith"),", ",(0,a.kt)("inlineCode",{parentName:"p"},"contains")," and ",(0,a.kt)("inlineCode",{parentName:"p"},"matches")," are also available."),(0,a.kt)("p",null,"For ",(0,a.kt)("inlineCode",{parentName:"p"},"NodeProperty<*>")," backed properties, the meta filter for the specific type is used.\nFor ",(0,a.kt)("inlineCode",{parentName:"p"},"NodeSetProperty<*>")," backed properties, the filter fields include  ",(0,a.kt)("inlineCode",{parentName:"p"},"all"),", ",(0,a.kt)("inlineCode",{parentName:"p"},"some")," and ",(0,a.kt)("inlineCode",{parentName:"p"},"none"),", each can be set to a type specific meta filter."),(0,a.kt)("p",null,"It is possible to support additional property types, by providing Spring beans of type ",(0,a.kt)("inlineCode",{parentName:"p"},"TypeFilterDefinitionEntry"),".\nHere an example for the Kotlin ",(0,a.kt)("inlineCode",{parentName:"p"},"Float")," type:"),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-kotlin"},"@Bean\nfun floatFilter() =\n    TypeFilterDefinitionEntry(Float::class.createType()) { name, property, parentNodeDefinition, _ ->\n        FloatFilterDefinition(name, parentNodeDefinition.getNeo4jNameOfProperty(property))\n    }\n")),(0,a.kt)("p",null,"Note that ",(0,a.kt)("inlineCode",{parentName:"p"},"TypeFilterDefinitionEntry")," are free to not create a filter definition by returning ",(0,a.kt)("inlineCode",{parentName:"p"},"null")," in the callback.\nThis is e.g. be used for filters for ",(0,a.kt)("inlineCode",{parentName:"p"},"Node(Set)Property<*>")," if the property has a generic type."),(0,a.kt)("admonition",{type:"info"},(0,a.kt)("p",{parentName:"admonition"},"Filter on ",(0,a.kt)("inlineCode",{parentName:"p"},"NodeProperty<*>")," and ",(0,a.kt)("inlineCode",{parentName:"p"},"NodeSetProperty<*>")," take the authorization system into account.\nConceptually, first the related nodes are filtered by the ",(0,a.kt)("inlineCode",{parentName:"p"},"Permission")," to only include nodes the Permission grants access to, then,\nthe filter is evaluated.\nThis prevents an information leak by filtering, however, at the cost of higher complexity.\nTherefore, use ",(0,a.kt)("inlineCode",{parentName:"p"},"@FilterProperty")," on properties which may include non-visible nodes with caution.")),(0,a.kt)("h4",{id:"additional-filters"},"Additional filters"),(0,a.kt)("p",null,"With the ",(0,a.kt)("inlineCode",{parentName:"p"},'AdditionalFilter("beanName")')," annotation, property independent filters can be defined.\nThis can for instance be used to filter by Node type, or a complex condition.\nA Spring bean with the specified name and type ",(0,a.kt)("inlineCode",{parentName:"p"},"FilterEntryDefinition")," has to be provided."),(0,a.kt)("h4",{id:"node-filter-generators"},"Node filter generators"),(0,a.kt)("p",null,"Bean of type ",(0,a.kt)("inlineCode",{parentName:"p"},"NodeFilterGenerator")," can be used to generate additional filter entries for any Node filters.\nIn contrast to ",(0,a.kt)("a",{parentName:"p",href:"#additional-filters"},"Additional filters"),", node filter generators allow for dynamically generating the entries\nbased on the provided ",(0,a.kt)("inlineCode",{parentName:"p"},"NodeDefinition"),", which allows e.g. implementing custom meta-filters (like xor)."))}h.isMDXComponent=!0}}]);